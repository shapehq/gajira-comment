{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;;;;;;;;;AASA","sources":[".././action.js",".././common/net/Jira.js",".././common/net/client.js","../../../../../../../../../opt/homebrew/Cellar/ncc/0.38.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../external node-commonjs \"url\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":["const Jira = require('./common/net/Jira')\nmodule.exports = class {\n  constructor ({ githubEvent, argv, config }) {\n    this.Jira = new Jira({\n      baseUrl: config.baseUrl,\n      token: config.token,\n      email: config.email,\n    })\n\n    this.config = config\n    this.argv = argv\n    this.githubEvent = githubEvent\n  }\n\n  async execute () {\n    const issueIds = this.argv.issues || this.config.issues || null\n    const { comment } = this.argv\n\n    // Error handling for empty or null issueIds\n    if (!issueIds) {\n      console.log('No issue IDs provided. Exiting without adding comments.')\n      return {}\n    }\n\n    const issueList = issueIds.split(\",\").filter(issueId => issueId.trim() !== '') // Filter out empty strings\n\n    // Additional check for empty issueList after filtering\n    if (issueList.length === 0) {\n      console.log('No valid issue IDs provided after filtering. Exiting without adding comments.')\n      return {}\n    }\n\n    console.log(`Adding comment to ${issueList.length} issues: \\n${comment}`)\n\n    for (const issueId of issueList) {\n      console.log(`Adding comment to ${issueId}`)\n      try {\n        await this.Jira.addComment(issueId, { body: comment })\n      } catch (error) {\n        console.error(`Failed to add comment to ${issueId}:`, error.message)\n      }\n    }\n\n    return {}\n  }\n}\n","const { get } = require('lodash')\n\nconst serviceName = 'jira'\nconst { format } = require('url')\nconst client = require('./client')(serviceName)\n\nclass Jira {\n  constructor ({ baseUrl, token, email }) {\n    this.baseUrl = baseUrl\n    this.token = token\n    this.email = email\n  }\n\n  async addComment (issueId, data) {\n    return this.fetch('addComment', {\n      pathname: `/rest/api/2/issue/${issueId}/comment`,\n    }, {\n      method: 'POST',\n      body: data,\n    })\n  }\n\n  async createIssue (body) {\n    return this.fetch('createIssue',\n      { pathname: '/rest/api/2/issue' },\n      { method: 'POST', body })\n  }\n\n  async getIssue (issueId, query = {}) {\n    const { fields = [], expand = [] } = query\n\n    try {\n      return this.fetch('getIssue', {\n        pathname: `/rest/api/2/issue/${issueId}`,\n        query: {\n          fields: fields.join(','),\n          expand: expand.join(','),\n        },\n      })\n    } catch (error) {\n      if (get(error, 'res.status') === 404) {\n        return\n      }\n\n      throw error\n    }\n  }\n\n  async getIssueTransitions (issueId) {\n    return this.fetch('getIssueTransitions', {\n      pathname: `/rest/api/2/issue/${issueId}/transitions`,\n    }, {\n      method: 'GET',\n    })\n  }\n\n  async transitionIssue (issueId, data) {\n    return this.fetch('transitionIssue', {\n      pathname: `/rest/api/3/issue/${issueId}/transitions`,\n    }, {\n      method: 'POST',\n      body: data,\n    })\n  }\n\n  async fetch (apiMethodName,\n    { host, pathname, query },\n    { method, body, headers = {} } = {}) {\n    const url = format({\n      host: host || this.baseUrl,\n      pathname,\n      query,\n    })\n\n    if (!method) {\n      method = 'GET'\n    }\n\n    if (headers['Content-Type'] === undefined) {\n      headers['Content-Type'] = 'application/json'\n    }\n\n    if (headers.Authorization === undefined) {\n      headers.Authorization = `Basic ${Buffer.from(`${this.email}:${this.token}`).toString('base64')}`\n    }\n\n    // strong check for undefined\n    // cause body variable can be 'false' boolean value\n    if (body && headers['Content-Type'] === 'application/json') {\n      body = JSON.stringify(body)\n    }\n\n    const state = {\n      req: {\n        method,\n        headers,\n        body,\n        url,\n      },\n    }\n\n    try {\n      await client(state, `${serviceName}:${apiMethodName}`)\n    } catch (error) {\n      const fields = {\n        originError: error,\n        source: 'jira',\n      }\n\n      delete state.req.headers\n\n      throw Object.assign(\n        new Error('Jira API error'),\n        state,\n        fields\n      )\n    }\n\n    return state.res.body\n  }\n}\n\nmodule.exports = Jira\n","const fetch = require('node-fetch')\n\nmodule.exports = serviceName => async (state, apiMethod = 'unknown') => {\n\n\tconst response = await fetch(state.req.url, state.req)\n\n\tstate.res = {\n\t\theaders: response.headers?.raw(),\n\t\tstatus: response.status,\n\t}\n\n\t// const tags = {\n\t//   api_method: apiMethod,\n\t//   method: state.req.method || 'GET',\n\t//   response_code: response.status,\n\t//   service: serviceName,\n\t// }\n\n\tstate.res.body = await response.text()\n\n\tconst isJSON = (response.headers.get('content-type') || '').includes('application/json')\n\n\tif (isJSON && state.res.body) {\n\t\tstate.res.body = JSON.parse(state.res.body)\n\t}\n\n\tif (!response.ok) {\n\t\tthrow new Error(response.statusText)\n\t}\n\n\treturn state\n}\n",null,"module.exports = require(\"fs\");","module.exports = require(\"url\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";"],"names":[],"sourceRoot":""}